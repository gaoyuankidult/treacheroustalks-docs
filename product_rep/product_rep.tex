\documentclass[11pt,a4paper]{report}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{datetime}
\usepackage{color}
\usepackage{url}

\newcommand{\hi}[1]{{\color{red}\em #1\/}\\}
\newcommand{\todo}[1]{\footnote{{\color{red} {\bf TODO:} #1}}}
\newcommand{\ask}[1]{\footnote{{\color{red} {\bf QUESTION:} #1}}}

\begin{document}
\title{Product Report \\
  ``Treacherous Talks''}
\date{\today\ @ \currenttime}
\author{Dilshod Aliev, Jan Daniel Bothma, Stephan Brandauer,\\
 Andre Hilsendeger, Rahim Kadkhodamohammadi, Xinze Lin,\\
Tiina Loukusa, Erik Timan, Sukumar Yethadka}
\maketitle
\tableofcontents

\abstract{
Treacherous Talks is an implementation of a board game (``Diplomacy'') as a web
service.

The report explains the project and takes a look at the requirements.
The technical details of the solutions chosen, are presented and their choices
motivated. The features that distinguish the project from existing implementations
are highlighted as well as some of our relative weaknesses are mentioned.
}

\chapter{Introduction}
Diplomacy is a board game, invented in the 1950s where the goal is to try to
conquer Europe just before WW I. You come close to this goal by talking to the
other players --- by diplomacy --- and making them your allies. And you achieve
it by attack them when they do not expect it.

The game is and was commonly played over distance --- starting with playing by
mail, then email and nowadays over pretty web pages with full-blown map
visualization.

The requirements we were faced with asked for implementation of Diplomacy as a
web service while providing several interfaces to this service. Scalability and
Failure Tolerance were of high priority. \\
Even though a board game is a fun thing to implement, we do think that the most
interesting part of our project is the scalability- and fault tolerance-
engineering.

\chapter{Preliminaries}
\hi{Describe important concepts, acronyms, tools you used in the process, target platforms, etc.}
\ask{regarding Releases, Applications: can we assume erlang-knowledge?}
\section{Releases}
\section{Applications}
\section{Scalability vs. Performance}

\chapter{System Description}
%\hi{System architecture, how it works.
%This is the core of your report, and is therefore most likely the largest section.}

\section{Requirements}

\subsection{Three Interfaces}
The requirement stated that we have to provide three interfaces that expose
the same functionality to the user (the operator is forced to use the
web~interface). Those interfaces are:\\
\begin{enumerate}
\item {\bf Web interface} ---
  the game should be accessible via a modern webbrowser {\em and\/} it should
  use websockets to communicate with the browser.
\item {\bf XMPP interface} ---
  the game should be accessible via a chat client using text based orders.
\item {\bf SMTP interface} ---
  the game should be accessible via sending of emails using text based orders.
\end{enumerate}

\subsection{Scalability}
The system should be scalable. Scalability in this context refers to horizontal scaling where the system should be able to handle more load by simply adding more nodes. No further explanations were provided regarding this feature, but since we saw it as a challenge we invested a lot of work into it.

\subsection{Fail-Safety}
The system should be highly available. We interpreted this by assuming that we
should handle hardware failure of physical machines. As with scalability, we
might have been able to get away with less work but this feature as well was
too interesting too resist focusing on it.

\subsection{Websockets}
Websockets are a tcp-like connection between a browser and a webserver.
They can be used to send javascript that updates only parts of the client page
instead of reloading a page and are a great tool to shift computing to the
client side.

The websockets feature was mostly an issue because of the tool support (or lack
thereof) we were faced with. More is explained in Sec.~\ref{sec:frontends}.
Otherwise, websockets are an amazing technology and will have a great impact on
web development in the future.

\subsection{AI}
Writing a simple AI was a requirement which interested us as well. However, we
were stuck in a tradeoff because time was limited: fail-safety+scalability
vs.\ AI players. In combination with our customer, we agreed on focusing on the
performance characteristics and leaving the AI players for future work.

\section{Architecture}
\subsection{Overview}
\todo{How modules communicate with each other}
% http://redmine.pcs/projects/dip/wiki/Communication
\todo{Supervision tree}
% http://redmine.pcs/projects/dip/wiki/Supervision_tree

\begin{figure}[h]
 \centering
 \includegraphics[width=13cm]{./graphics/arch.pdf}
 \caption{a possible cluster}
 \label{fig:arch}
\end{figure}

Our Architecture is divided in three main blocks, the {\em frontends}, the
{\em controller}, and the {\em backends}. In Fig.~\ref{fig:arch} a running
cluster as it could be configured is shown. {\em Machine 1} shows a full
configuration as it includes all three frontends, a backend and riak. The
operator, however, is free to choose to only run a specific selection of these
and can combine them freely.

The responsibilities are not surprising: the frontends receive user input and
transform the input into messages which are sent to the controller.
The controller filters out illegal messages according to the session database
and the user privileges before handing them off to the backends --- which will
respond with an answer.
\subsubsection{Modularity --- and its Relation to Scalability}
One thing that is not immediately visible in our architecture is the fact that
the individual modules are very independent of each other. Even though the
architecture graphic shows a complete example of a running sample, we can choose
to run some modules alone. \\
If we would, for example, find out that our system is slow because the
web~frontend is the bottleneck, we could add more servers to the cluster that
run only a web~frontend (see Fig.~\ref{fig:arch}, ``Server n-1'').
We can do the same with each frontend types, with backends and with riak nodes.
Our architecture, therefore, inherently supports scaling out very well.
Since the frontends are not relying on each other at all (they are completely
parallel), we did not spend resources on load testing them since we needed that
time to benchmark and load test our backends and riak nodes.
\subsection{Frontends}
\label{sec:frontends}
The frontends speak almost the same language to the user, which made the
implementation of front-end logic very generic.

\subsubsection{Web}
The web frontend is running yaws as a web server, after deciding to use nitrogen
as a web framework, we had to drop nitrogen because of the websockets
requirement. Yaws is configured as a ``/" application module (appmod) so that we can have a single entry point for handling all the requests. Server side includes (ssi) are also used to load static content via ajax.

The web frontend relies heavily on javascript since it contains a good part of the application logic handling user interactions, requests, responses and game functionalities. We also use the toolkit Bootstrap\cite{bootstrap} for the user interface which allows us to quickly develop clean pages.\\

We had the option to extend Nitrogen to support websockets, but after spending
some time investigating the possibility and walking through the code to
understand it properly, we came to the conclusion that it would be a project on
its own to do that. Nitrogen uses SimpleBridge which provides a standardized
interface to all its supported web servers. We found that adding websockets
would mean to change/add a lot of code, in a lot of modules, the way
Nitrogen/SimpleBridge is structured. Instead, as previously mentioned, the web
frontend is using plain javascript, which is very conventient for creating a
websocket connection.

Throughout the course of the project the websocket handshake protocol has
been changing.
Not until the end of the project has a protocol (RFC 6455) been released that
has been proposed to be the official standard, we did not have the resources
to update our system whenever a new version was released. Instead, a decision
on what version to support had to be made in the beginning of the project, so we
could focus developing our product.
It would influence what webserver to use and which web browser to support. We
chose hybi-10, that is what the yaws server that is running, and Chromium 14
which we developed for, supports.\todo{JD: correct if inaccurate or fix if yaws is updated}

\subsubsection{XMPP}
Using ejabberd as XMPP server was an obvious choice since ejabberd is widely
regarded as the standard solution for XMPP servers and ejabberd is implemented
in Erlang which led us to hope that it would play well with our code. \todo{People involved: tell a story}
\subsubsection{SMTP}
SMTP, together with POP and IMAP are the three most prevalent protocols for today's email servers.
And SMTP itself is used for sending email from client to server while POP or IMAP
are used for retrieving email from server to client.
For our email server, we found three quilified candidates: Erlmail, gen\_smtp and erlang-smtp.
At first sight, Erlmail seemed to be the most competitive one since it supports all these three
protocols when others support only one or two of them.
But since our SMTP frontend doesn't directly talk to email clients, we figured out
that there's no need for email retrieving mechanism for our servers. Therefore,
we picked gen\_smtp server as our SMTP frontend since all of its modules are only focused
on SMTP. In our system architecture, the SMTP frontend is the bridge between client side and the backend
(see Fig.~\ref{fig:smtp_arch}).
Once the SMTP frontend receives an email from the client side, it will extract the
email content and pass it to the backend controller. The controller will interpret and execute
the valid orders carried by the email content, then respond to client side through the SMTP frontend again.

\begin{figure}[h]
 \centering
 \includegraphics[width=5cm]{./graphics/smtp_arch.pdf}
 \caption{Communication between client side and backend}
 \label{fig:smtp_arch}
\end{figure}

\subsection{Controller}
The main characteristic distinguishing requests is whether they belong to a session or not.
So the controller has two kinds of workers.
Those responsible for requests with a session and those for requests without.

The simple ones without sessions are completely stateless and can handle requests from any user.
They are spawned on startup and will handle requests on arrival.
Their main responsibilities are registration, login and the like.

\subsubsection{Session Management}
The session management consists of a group of processes and a mnesia table.
Each session spawns its own session process and writes an entry into the mnesia table,
so that one such process exists for each logged in user.
The mnesia table is necessary to have a mapping between users and sessions.
The processes handle all requests for their session and have the session data
(user data, knowledge of how to push events to the frontend, etc).
The reasons for that are concurrency issues (more on that in \ref{sec:concurrency}).


\subsubsection{Access Control}
What users can perform what actions on the system is defined by a set of identities known as roles. The system has four roles.

\begin{itemize}
\item User --- registered member of the system who can create and play games
\item Blacklisted user --- a user who has been removed from the system
\item Moderator --- a user with enhanced privileges to moderate games and help other users
\item Operator --- an administrator who has complete control over the system

\end{itemize}

\subsection{Backend}
\subsubsection{Game Managing}
Managing games was split up in two main tasks: {\em game timing\/} and
{\em order-processing}. \\
Game timing was implemented as a {\tt gen\_fsm} that changes states when a game
phase needs to stop, eg.\ when the deadline for handing in orders is over.\\
Before a phase is started, the rules processing is done by a module we call
the ``rule engine'': the orders which were sent by the users before the deadline
are read from the database and passed, along with the current game map, to the
rule engine.
\subsubsection{Messaging}
Since communication is very important in the game --- some even say, that the
game is mostly about communication --- the messaging module was a very central
feature for us. We support two types of messages: {\em in-game\/} and
{\em off-game\/}-messages.\\
Messages in game never involve the user name for
tactical reasons: if someone remembers my nickname, he has an easier time to
anticipate my moves since he will most likely remember my actions in last games.
Or, worse: he might still hold a grudge against me. This is why you never
communicate with players in-game by using their nickname, but by using their
country.

Off-game messages on the other hand are sent to a nickname and the recipient
will see the sender's nickname. The basic usecase for the off-game messaging is
giving users the chance to set up games for their friends and tell them about
it.
\subsubsection{Search}
Our search module provides the functionality to search, for instance, for games,
based on their properties (like all game parameters). For the implementation of
search, we relied on the riak extension {\tt riak\_search}.

Riak search is a search engine that is tightly coupled with the Riak datastore.
We add a precommit hook to the properties of the bucket whose data is to be
searched along with search schema which specifies how the object is to be indexed.
Whenever a new object is added or an old one updated, the object is indexed
(tokenization with standard Lucene analyzers) and saved.
It provides a rich query language consisting of term searches, field searches,
boolean operators and wildcards to fetch matching objects ordered by relevance.

This feature comes with a price though and should be used with caution.
During load testing we discovered, that it should be avoided for often updated data.
As it has to re-index all fields of an object on every write it can kill the performance.
Therefore we tried minimizing writes on search indexed data and if possible not
to use the riak search feature at all.

\subsubsection{User Management}
The user management module was one of the first modules we implemented in the
backend; its purpose is to create, update, read, delete users in or from the
database. The implementation is quite short and should contain few surprises.

\subsection{Riak}
The choice of riak as database was a careful one: we evaluated riak, couchDB
and mnesia but riak was our favourite in the end --- its scalability features
are very simple to use and its potential for scalability is what we needed.
Due to consistency issues, we had to resort to using mnesia for sessions and
the game joining processes, as it provides transactions.

Riak proved to be a good choice for us since its performance parameters (called
``CAP controls'' in riak-lingo) are very easy to tune and it is quite well
documented how riak behaves under load. The scalability problems we had
came from using the search module too much.
\subsubsection{eleveldb}
Another problem was riak's storage backend. Riak has the feature to switch the
storage backend --- the way, key/value pairs are stored on a node.
We initially used {\tt eleveldb} because it supported secondary indices, a
feature we wanted have. {\tt eleveldb} however showed degrading performance
in our context: the throughput of database operations was decreasing linearly
over time, down to zero. We could not find out what the problem was, so
we had to switch the storage backend to {\tt bitcask}, riak's standard storage
backend. Bitcask does not support secondary indices, and because of that it was
necessary to use {\tt riak\_search} more --- which led to scalability
issues\ldots

\subsubsection{Mnesia}
A user can access our system from multiple frontends resulting in
concurrency issues. We dealt with them by making sure that the user
can use only one frontend at a time.

Another issue was that multiple orders sent by the same user can arrive at the
backend in a different sequence creating inconsistent data. This was
fixed by serializing the user's commands.

The implementation of the above two solutions was not possible using Riak since
its an eventually consistent database. Mnesia, which is distributed and has
transactions, was the right fit.

We used Mnesia to keep track of user sessions. Combining this with
the use of one Erlang process per session, the implementation was complete.

\subsection{Concurrency}
\label{sec:concurrency}
\todo{How we deal with concurrency and conflicts}
% http://redmine.pcs/projects/dip/wiki/Concurrency_handling

\section{Code organization}

The project consists of a set of Erlang applications logically grouped
based on their functionalities. We have two more directories at the
project level, one for external tests and the other for the release.

Below is the high level directory structure of the project.

\begin{verbatim}
   |-apps
   |---cluster_manager
   |---controller_app
   |---datatypes
   |---db
   |---game
   |---gen_moves
   |---load_test
   |---message
   |---necromancer
   |---service
   |---smtp_frontend
   |---system_manager
   |---user_management
   |---utils
   |---web_frontend
   |---xmpp_lib
   |-ext_test
   |---bench
   |---fault_tolerance
   |---smtp_integration_test
   |---websocket_client
   |---xmpp_integration_test
   |-rel
\end{verbatim}

Briefly describing the applications,

\begin{center}
    \begin{tabular}{ | l | p{10cm} |}
    \hline
    Application & Description \\ \hline \hline
    cluster\_manager & escript for management of the distributed
    cluster \\ \hline
    controller\_app & The controller application \\ \hline
    datatypes & A central place for common configuration. It contains bucket
    names and records \\ \hline
    db & The database wrapper that handles all the db requests\\ \hline
    game & Contains game logic, game timer, rule engine and other game
    related code \\ \hline
    gen\_moves & Generates moves that can be used for load testing \\ \hline
    load\_test & Code used for load testing \\ \hline
    message & Code used for handling messages \\ \hline
    necromancer & Code used for resurrecting dead VMs \\ \hline
    service &  OTP application library that provides functionality used by
    all service applications \\ \hline
    smtp\_frontend & Handles all the mail communication \\ \hline
    system\_manager & Single point of entry for configuring and controlling
    the whole system on a server. \\ \hline
    user\_management & Handles all user related functions \\ \hline
    utils & Commonly used tools and utilities \\ \hline
    web\_frontend & Code for handling the web frontend, including client
    side code \\ \hline
    xmpp\_lib & Library for handling XMPP communication \\ \hline \hline
    \end{tabular}
\end{center}



Additional notes on the code,

\begin{itemize}
\item General Erlang coding style and conventions were followed.
\item The public API of all the modules has specs and edocs.
\end{itemize}


\chapter{Treacherous Talks}
\hi{Describe the product from a user perspective, what you can do / what it looks like.}
\section{The Three Interfaces}
\subsection{HTTP}
The user goes to the landing page, there he finds a link to register which will
display a simple form for him to fill out. After the user is registered, he is
able to log in using the login textfields on the landing page.

After logging in, the user is shown an overview page (see Fig.~\ref{fig:overview})
 where he is able to search for games, look at the games he is playing in (if any) and
chat with other users in-game or off-game.

\begin{figure}[h]
 \centering
 \includegraphics[width=\textwidth]{./graphics/overviewpage.png}
 \caption{the overview page}
 \label{fig:overview}
\end{figure}

The web frontend has several key advantages over the two purely text based
frontends:
\begin{itemize}
\item the user does not need to remember his session id
\item the user sees a graphical map (generated using a HTML5 canvas!),
  see Fig.~\ref{fig:map}
\item it is easier to enter move orders because possible orders are represented
  as drop-down lists, see Fig.~\ref{fig:orders}
\end{itemize}

\begin{figure}[h]
 \centering
 \includegraphics[width=10cm]{./graphics/graphicalmap.png}
 \caption{the graphical map}
 \label{fig:map}
\end{figure}

\begin{figure}[h]
 \centering
 \includegraphics[width=10cm]{./graphics/orderssmall.png}
 \caption{the orders drop-down lists}
 \label{fig:orders}
\end{figure}

\subsection{XMPP}
\todo{Rahim: explain}
\subsection{SMTP}
\todo{Lin: explain}
\section{Messages}
In the web frontend, the user is shown two chat boxes: one for off-game chat
and one for ingame-chat. The user manually has to enter the recipient (in
in-game chat the recipient-country and the game ID). If the recipient is not
online when a message is sent, it will be stored and delivered by the message
application after the recipient logs in the next time. \\
\todo{People involved: explain text based message sending}

\section{Playing}
The web frontend generates drop down lists to make it easier for the user to
enter move orders as shown in Fig.~\ref{fig:orders} \\
The other two (XMPP and SMTP) frontends take text based orders. Instead of
clicking, the user has to type them and additionally is required to supply
his session ID which he receives after logging in. A dialog between user and
system via XMPP could look like this: \todo{sample dialog via text interface}

\chapter{Evaluation and Testing}
%\hi{Describe what experiments you have done to test your product.}
\section{Overview}
We approached testing very seriously from the start and are confident that this
was one of the best decisions we made throughout the project. Unit tests are too
low level to be covered here but they are of course there. We used EUnit for
most of our testing and where generally happy with that choice except for one
thing: EUnit declares a test as failed as soon as it runs for 5 seconds and
there is no central way to change that behaviour. It's possible to do it for
single tests, but the code duplication in that case is, of course, sub-optimal.
That 5 seconds ``feature'' was especially annoying in combination with
continuous integration: our build server had a lot to work and therefore was
interacting with our database a lot. When several builds were running at the
same time, the database would get slower, therefore pushing tests over the
time-limit, even though they ran perfectly fine on our local machines. Had we
known this issue beforehand, we would have looked more into alternatives of
EUnit.

\section{Integration Tests}
Our integration tests tried to cover everything from the frontends down to the
database. It showed, that the xmpp frontend was the easiest to be tested, so
our tests for smtp- and web-frontend are only testing the basics --- ``it's
there and it reacts'' --- while the xmpp tests send orders, register to the
system, log in, log off, and so on.

\section{Load Tests}
In sprint 4, we started to work on load testing our system. We found it very
hard to get meaningful data from our testruns but even the first, quite informal
load tests resulted in very valuable information.

Load testing was never ran fully automated. Although that would be very useful,
this would have been impossible for us since we would have needed a seperate
cluster to do that and just could not get that amount of hardware.
A smaller automated test on one dedicated machine would have probably helped
already but was not implemented due to time-constraints.

From the start of the load testing, practically no night was unused: tests were
running through the night and were evaluated in the next morning.

It was necessary to write a considerable amount of load-testing-scripts that
distributed our releases across a varying number of nodes, started and connected
them and did the actual load generation. But: the time spent on this was time
spent very well, since it ensured that performance drops because of single
commits were noticed in several instances --- and their cause analyzed.
\todo{include last minute results}
\section{Failure Tests}
Our failure tolerance test starts up a cluster of two backends A and B and starts
a game.
Since we do not know on which backend the game has been started, we halt
backend~A. If fault tolerance works, we can now be sure that the game is on backend~B
(either it was there in the first place or it got restarted there).
We start the backend~A again and then halt backend~B. Now the game gets moved to
backend~A. This way, we can be sure that the game was moved at least once.
If the game continues to run, the test was successful.

\chapter{Related Work}
%\hi{Similarities with existing products/systems. How are you similar and how are you different? What do you do better? What can you learn from what's already out there?

%It is possible that you want to have this section earlier, before the system description, perhaps as a part of (the end of) the product description, so that you can refer to it later.}

Diplomacy has been around since the 1950s and has been played by email, snail
mail and through web browsers. Obviously, we are not going to compare ourselves
to the snail mail solution where a game host receives letters with move orders
from the players and the players send each other letters.

Noteworthy browser based solutions are:\\
\begin{tabular}{lc}
  page                            & registered users \\
  \url{http://webdiplomacy.net}   & 40613 \\
  \url{http://playdiplomacy.com/} & 6849
\end{tabular}

The alternative email solutions seem to have even lower user numbers but precise
details are hard to be found. Please note that the numbers in
the table are about {\em registered\/} users, while our benchmarks are in terms
of {\em active\/} users.

The advantages the existing solutions have, are generally better interfaces: \\
the existing email systems are a bit easier to use since you reference games by
name and not by a number and there is no session id handling involved.
These issues would be fixable with reasonable resources though. \\
The web interfaces provide better user interfaces as well --- a clickable map
is the norm (click on a unit and then on the target province to issue a move
order, for instance) as well as the timing is handled a bit nicer. They also
provide several game modes (from minor changes to starting units to playing on
a world map). We have the code to handle new maps, but we don't have the map
data. Creating those would be easy but involve a lot of typing.

Our rules are not perfect yet, they are still a bit rough around the edges but
in probably one or two person weeks would work satisfyingly well.
When it comes to load, we see no problem in handling all web diplomacy
players worldwide (email- and browser-based) with one backend-machine and maybe
more extra frontend machines.

So, in short: to fully catch up with the alternatives, we would need to invest
in bug fixing and user interaction.

\chapter{Conclusions and Future Work}
We are very happy with the work we have done and that the product is, even though
the seemingly endless scope, quite close to being ``ready''.

Despite all this, the work that has to be done is considerable:
An AI was in the original requirements but was not delivered due to time constraints.
Bug fixing in the rule engine is necessary. Scalability could be improved by applying
tracing to the cluster which would be lots of interesting work. as well as the
interfaces polished.

In order to make the game playable by the public, a better system to find and join 
games would probably be necessary in the web frontend --- and we would need to
do lots of hallway testing and/or maybe publish an alpha version in order to collect
feedback.

One more thing would be to think a lot about security --- not much thought has been
spent on it yet.

The rule engine does not support multi-fleet convoys yet but they are important for
the game tactics (the classic Italian opening called ``lepanto~opening'' uses it, for
instance). This could be done quite easily in the rule engine.

\appendix
\chapter{Installation Instructions}
\todo{Erik}

\chapter{Maintenance Instructions}
\todo{Erik}

\end{document}
